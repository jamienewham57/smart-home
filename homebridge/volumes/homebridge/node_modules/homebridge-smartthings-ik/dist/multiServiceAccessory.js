"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiServiceAccessory = void 0;
const axios = require("axios");
// import { BasePlatformAccessory } from './basePlatformAccessory';
const motionService_1 = require("./services/motionService");
const batteryService_1 = require("./services/batteryService");
const temperatureService_1 = require("./services/temperatureService");
const humidityService_1 = require("./services/humidityService");
const lightSensorService_1 = require("./services/lightSensorService");
const contactSensorService_1 = require("./services/contactSensorService");
const lockService_1 = require("./services/lockService");
const doorService_1 = require("./services/doorService");
const switchService_1 = require("./services/switchService");
const lightService_1 = require("./services/lightService");
const fanSwitchLevelService_1 = require("./services/fanSwitchLevelService");
const occupancySensorService_1 = require("./services/occupancySensorService");
const leakDetector_1 = require("./services/leakDetector");
const smokeDetector_1 = require("./services/smokeDetector");
const carbonMonoxideDetector_1 = require("./services/carbonMonoxideDetector");
const valveService_1 = require("./services/valveService");
const fanSpeedService_1 = require("./services/fanSpeedService");
const windowCoveringService_1 = require("./services/windowCoveringService");
const thermostatService_1 = require("./services/thermostatService");
const statelessProgrammableSwitchService_1 = require("./services/statelessProgrammableSwitchService");
const airConditionerService_1 = require("./services/airConditionerService");
const smartThingsCommand_1 = require("./services/smartThingsCommand");
// type DeviceStatus = {
//   timestamp: number;
//   //status: Record<string, unknown>;
//   status: any;
// };
/**
 * Platform Accessory
 * An instance of this class is created for each accessory your platform registers
 * Each accessory may expose multiple services of different service types.
 */
// export class MultiServiceAccessory extends BasePlatformAccessory {
class MultiServiceAccessory {
    get id() {
        return this.accessory.UUID;
    }
    constructor(platform, accessory) {
        //  service: Service;
        //capabilities;
        this.components = [];
        /**
         * These are just used to create a working example
         * You should implement your own code to track the state of your accessory
         */
        this.services = [];
        this.online = true;
        //protected deviceStatus: DeviceStatus = { timestamp: 0, status: undefined };
        this.deviceStatusTimestamp = 0;
        this.failureCount = 0;
        this.giveUpTime = 0;
        this.commandInProgress = false;
        this.lastCommandCompleted = 0;
        this.statusQueryInProgress = false;
        this.lastStatusResult = true;
        this.accessory = accessory;
        this.platform = platform;
        this.name = accessory.context.device.label;
        this.log = platform.log;
        this.baseURL = platform.config.BaseURL;
        this.key = platform.config.AccessToken;
        this.api = platform.api;
        const headerDict = { 'Authorization': 'Bearer: ' + this.key };
        this.axInstance = axios.default.create({
            baseURL: this.baseURL,
            headers: headerDict,
        });
        this.commandURL = 'devices/' + accessory.context.device.deviceId + '/commands';
        this.statusURL = 'devices/' + accessory.context.device.deviceId + '/status';
        this.healthURL = 'devices/' + accessory.context.device.deviceId + '/health';
        this.characteristic = platform.Characteristic;
        // set accessory information
        accessory.getService(platform.Service.AccessoryInformation)
            .setCharacteristic(platform.Characteristic.Manufacturer, accessory.context.device.manufacturerName)
            .setCharacteristic(platform.Characteristic.Model, 'Default-Model')
            .setCharacteristic(platform.Characteristic.SerialNumber, 'Default-Serial');
        // // Find out if we are online
        this.axInstance.get(this.healthURL)
            .then(res => {
            if (res.data.state === 'ONLINE') {
                this.online = true;
            }
            else {
                this.online = false;
            }
        });
    }
    registerServiceIfMatchesCapabilities(componentId, component, capabilitiesToCover, capabilities, optionalCapabilities, serviceConstructor) {
        // this.log.debug(`Testing ${serviceConstructor.name} for capabilities ${capabilitiesToCover}`);
        // ignore services which cannot cover all required capabilities
        if (!capabilities.every(e => capabilitiesToCover.includes(e))) {
            // this.log.debug(`Ignoring ${serviceConstructor.name}`);
            return capabilitiesToCover;
        }
        const allCapabilities = capabilities.concat(optionalCapabilities.filter(e => capabilitiesToCover.includes(e)));
        this.log.debug(`Creating instance of ${serviceConstructor.name} for capabilities ${allCapabilities}`);
        const serviceInstance = new serviceConstructor(this.platform, this.accessory, componentId, allCapabilities, this, this.name, component);
        this.services.push(serviceInstance);
        this.log.debug(`Registered ${serviceConstructor.name} for capabilities ${allCapabilities}`);
        // remove covered capabilities and return unused
        return capabilitiesToCover.filter(e => !allCapabilities.includes(e));
    }
    addComponent(componentId, capabilities) {
        const component = {
            componentId,
            capabilities,
            status: {},
        };
        this.components.push(component);
        let capabilitiesToCover = [...capabilities];
        // Start with comboServices and remove used capabilities to avoid duplicated sensors.
        // For example, there is no need to expose a temperature sensor in case of a thermostat which already exposes that charateristic.
        MultiServiceAccessory.comboCapabilityMap
            .sort((a, b) => a.capabilities.length > b.capabilities.length ? -1 : 1) // services with larger capability set first
            .forEach(entry => {
            capabilitiesToCover = this.registerServiceIfMatchesCapabilities(componentId, component, capabilitiesToCover, entry.capabilities, entry.optionalCapabilities || [], entry.service);
        });
        Object.keys(MultiServiceAccessory.capabilityMap).forEach((capability) => {
            const service = MultiServiceAccessory.capabilityMap[capability];
            capabilitiesToCover = this.registerServiceIfMatchesCapabilities(componentId, component, capabilitiesToCover, [capability], [], service);
        });
    }
    isOnline() {
        return this.online;
    }
    // Find return if a capability is supported by the multi-service accessory
    static capabilitySupported(capability) {
        if (Object.keys(MultiServiceAccessory.capabilityMap).find(c => c === capability)) {
            return true;
        }
        else {
            return false;
        }
    }
    // public async refreshStatus(): Promise<boolean> {
    //   return super.refreshStatus();
    // }
    // Called by subclasses to refresh the status for the device.  Will only refresh if it has been more than
    // 4 seconds since last refresh
    //
    async refreshStatus() {
        return new Promise((resolve) => {
            this.log.debug(`Refreshing status for ${this.name} - current timestamp is ${this.deviceStatusTimestamp}`);
            if (Date.now() - this.deviceStatusTimestamp > 5000) {
                // If there is already a call to smartthings to update status for this device, don't issue another one until
                // we return from that.
                if (this.statusQueryInProgress) {
                    this.log.debug(`Status query already in progress for ${this.name}.  Waiting...`);
                    this.waitFor(() => !this.statusQueryInProgress).then(() => resolve(this.lastStatusResult));
                    return;
                }
                this.log.debug(`Calling Smartthings to get an update for ${this.name}`);
                this.statusQueryInProgress = true;
                this.failureCount = 0;
                this.waitFor(() => this.commandInProgress === false).then(() => {
                    this.lastStatusResult = true;
                    this.axInstance.get(this.statusURL).then((res) => {
                        const componentsStatus = res.data.components;
                        this.components.forEach(component => {
                            if (componentsStatus[component.componentId] !== undefined) {
                                component.status = componentsStatus[component.componentId];
                                this.deviceStatusTimestamp = Date.now();
                                this.log.debug(`Updated status for ${this.name}-${component.componentId}: ${JSON.stringify(component.status)}`);
                            }
                            else {
                                this.log.error(`Failed to get status for ${this.name}-${component.componentId}`);
                            }
                        });
                        this.statusQueryInProgress = false;
                        resolve(true);
                        // if (res.data.components.main !== undefined) {
                        //   this.deviceStatus.status = res.data.components.main;
                        //   this.deviceStatus.timestamp = Date.now();
                        //   this.log.debug(`Updated status for ${this.name}: ${JSON.stringify(this.deviceStatus.status)}`);
                        //   this.statusQueryInProgress = false;
                        //   resolve(true);
                        // } else {
                        //   this.log.debug(`No status returned for ${this.name}`);
                        //   this.statusQueryInProgress = false;
                        //   resolve(this.lastStatusResult = false);
                        // }
                    }).catch(error => {
                        this.failureCount++;
                        this.log.error(`Failed to request status from ${this.name}: ${error}.  This is failure number ${this.failureCount}`);
                        if (this.failureCount >= 5) {
                            this.log.error(`Exceeded allowed failures for ${this.name}.  Device is offline`);
                            this.giveUpTime = Date.now();
                            this.online = false;
                        }
                        this.statusQueryInProgress = false;
                        resolve(this.lastStatusResult = false);
                    });
                });
            }
            else {
                resolve(true);
            }
        });
    }
    forceNextStatusRefresh() {
        this.deviceStatusTimestamp = 0;
    }
    // public startPollingState(pollSeconds: number, getValue: () => Promise<CharacteristicValue>, service: Service,
    //   chracteristic: WithUUID<new () => Characteristic>, targetStateCharacteristic?: WithUUID<new () => Characteristic>,
    //   getTargetState?: () => Promise<CharacteristicValue>) {
    //   return super.startPollingState(pollSeconds, getValue, service, chracteristic, targetStateCharacteristic, getTargetState);
    // }
    startPollingState(pollSeconds, getValue, service, chracteristic, targetStateCharacteristic, getTargetState) {
        if (this.platform.config.WebhookToken && this.platform.config.WebhookToken !== '') {
            return; // Don't poll if we have a webhook token
        }
        if (pollSeconds > 0) {
            return setInterval(() => {
                // If we are in the middle of a commmand call, or it hasn't been at least 10 seconds, we don't want to poll.
                if (this.commandInProgress || Date.now() - this.lastCommandCompleted < 20 * 1000) {
                    // Skip polling until command is complete
                    this.log.debug(`Command in progress, skipping polling for ${this.name}`);
                    return;
                }
                if (this.online) {
                    this.log.debug(`${this.name} polling...`);
                    // this.commandInProgress = true;
                    getValue().then((v) => {
                        service.updateCharacteristic(chracteristic, v);
                        this.log.debug(`${this.name} value updated.`);
                    }).catch(() => {
                        this.log.warn(`Poll failure on ${this.name}`);
                        return;
                    });
                    // Update target if we have to
                    if (targetStateCharacteristic && getTargetState) {
                        //service.updateCharacteristic(targetStateCharacteristic, getTargetState());
                        getTargetState().then(value => service.updateCharacteristic(targetStateCharacteristic, value));
                    }
                }
                else {
                    // If we failed this accessory due to errors. Reset the failure count and online status after 10 minutes.
                    if (this.giveUpTime > 0 && (Date.now() - this.giveUpTime > (10 * 60 * 1000))) {
                        this.axInstance.get(this.healthURL)
                            .then(res => {
                            if (res.data.state === 'ONLINE') {
                                this.online = true;
                                this.giveUpTime = 0;
                                this.failureCount = 0;
                            }
                        });
                    }
                }
            }, pollSeconds * 1000 + Math.floor(Math.random() * 1000)); // Add a random delay to avoid collisions
        }
    }
    async sendCommand(capability, command, args) {
        const cmd = new smartThingsCommand_1.Command(capability, command, args);
        return this.sendCommands([cmd]);
    }
    async sendCommands(commands) {
        const commandBody = JSON.stringify({ commands: commands });
        return new Promise((resolve) => {
            this.waitFor(() => !this.commandInProgress).then(() => {
                this.commandInProgress = true;
                this.axInstance.post(this.commandURL, commandBody).then(() => {
                    this.log.debug(`${JSON.stringify(commands)} successful for ${this.name}`);
                    this.deviceStatusTimestamp = 0; // Force a refresh on next poll after a state change
                    this.commandInProgress = false;
                    resolve(true);
                    // Force a small delay so that status fetch is correct
                    // setTimeout(() => {
                    //   this.log.debug(`Delay complete for ${this.name}`);
                    //   this.commandInProgress = false;
                    //   resolve(true);
                    // }, 1500);
                }).catch((error) => {
                    this.commandInProgress = false;
                    this.log.error(`${JSON.stringify(commands)} failed for ${this.name}: ${error}`);
                    resolve(false);
                });
            });
        });
    }
    // Wait for the condition to be true.  Will check every 500 ms
    async waitFor(condition) {
        if (condition()) {
            return;
        }
        this.log.debug(`${this.name} command or request is waiting...`);
        return new Promise(resolve => {
            const interval = setInterval(() => {
                if (condition()) {
                    this.log.debug(`${this.name} command or request is proceeding.`);
                    clearInterval(interval);
                    resolve();
                }
                this.log.debug(`${this.name} still waiting...`);
            }, 250);
        });
    }
    processEvent(event) {
        this.log.debug(`Received events for ${this.name}`);
        const service = this.services.find(s => s.componentId === event.componentId && s.capabilities.find(c => c === event.capability));
        if (service) {
            this.log.debug(`Event for ${this.name}:${event.componentId} - ${event.value}`);
            service.processEvent(event);
        }
    }
}
exports.MultiServiceAccessory = MultiServiceAccessory;
// Order of these matters.  Make sure secondary capabilities like 'battery' and 'contactSensor' are at the end.
MultiServiceAccessory.capabilityMap = {
    'doorControl': doorService_1.DoorService,
    'lock': lockService_1.LockService,
    'switch': switchService_1.SwitchService,
    'windowShadeLevel': windowCoveringService_1.WindowCoveringService,
    'windowShade': windowCoveringService_1.WindowCoveringService,
    'motionSensor': motionService_1.MotionService,
    'waterSensor': leakDetector_1.LeakDetectorService,
    'smokeDetector': smokeDetector_1.SmokeDetectorService,
    'carbonMonoxideDetector': carbonMonoxideDetector_1.CarbonMonoxideDetectorService,
    'presenceSensor': occupancySensorService_1.OccupancySensorService,
    'temperatureMeasurement': temperatureService_1.TemperatureService,
    'relativeHumidityMeasurement': humidityService_1.HumidityService,
    'illuminanceMeasurement': lightSensorService_1.LightSensorService,
    'contactSensor': contactSensorService_1.ContactSensorService,
    'button': statelessProgrammableSwitchService_1.StatelessProgrammableSwitchService,
    'battery': batteryService_1.BatteryService,
    'valve': valveService_1.ValveService,
};
// Maps combinations of supported capabilities to a service
MultiServiceAccessory.comboCapabilityMap = [
    {
        capabilities: [
            'switch',
            'airConditionerMode',
            'airConditionerFanMode',
            'thermostatCoolingSetpoint',
            'temperatureMeasurement',
        ],
        optionalCapabilities: [
            'fanOscillationMode',
            'relativeHumidityMeasurement',
            'custom.airConditionerOptionalMode',
        ],
        service: airConditionerService_1.AirConditionerService,
    },
    {
        capabilities: ['switch', 'fanSpeed', 'switchLevel'],
        service: fanSwitchLevelService_1.FanSwitchLevelService,
    },
    {
        capabilities: ['switch', 'fanSpeed'],
        service: fanSpeedService_1.FanSpeedService,
    },
    {
        capabilities: ['switch', 'switchLevel'],
        service: lightService_1.LightService,
    },
    {
        capabilities: ['switch', 'colorControl'],
        service: lightService_1.LightService,
    },
    {
        capabilities: ['switch', 'colorTemperature'],
        service: lightService_1.LightService,
    },
    {
        capabilities: ['switch', 'valve'],
        service: valveService_1.ValveService,
    },
    {
        capabilities: ['temperatureMeasurement',
            'thermostatMode',
            'thermostatHeatingSetpoint',
            'thermostatCoolingSetpoint'],
        service: thermostatService_1.ThermostatService,
    },
    {
        capabilities: ['windowShade', 'windowShadeLevel'],
        service: windowCoveringService_1.WindowCoveringService,
    },
    {
        capabilities: ['windowShade', 'switchLevel'],
        service: windowCoveringService_1.WindowCoveringService,
    },
];
//# sourceMappingURL=multiServiceAccessory.js.map